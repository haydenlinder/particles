<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particles</title>

    <link rel="stylesheet" href="./index.css">

    <!-- jquery -->
    <script 
        src="https://code.jquery.com/jquery-3.4.1.slim.js"
        integrity="sha256-BTlTdQO9/fascB1drekrDVkaKd9PkwBymMlHOiG+qLI=" 
        crossorigin="anonymous">
    </script>
    <!-- three.js -->
    <script 
        src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.js"
        integrity="sha256-+5R1zw/Tcxp82QhhfAJlicTeM4LCzFxp6EvsZW3V9bE=" 
        crossorigin="anonymous">
    </script>
    <!-- postprocessing -->
    <script src="https://cdn.jsdelivr.net/npm/postprocessing@6.13.2/build/postprocessing.min.js"></script>
    <!-- dat.gui -->
    <script 
        src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.js"
        integrity="sha256-/ROqjaHRlcpmCdy3tSetfsVbS6KcYJo9BEID29zqfYs=" 
        crossorigin="anonymous">
    </script>
</head>
<body>
    <div class="top">
        <div class="info">
            <header>
                <h1>Particles</h1>
                <a href="https://github.com/haydenlinder/particles">
                    <img src="git.png" class="git">
                </a>
                <p class="desc">An orbital physics simulator</p>
            </header>
            <div class="bar"></div>
            <section>
                <p>• Set conditions for a new universe and click restart to watch it develop from any angle or zoom level.</p>
                <p>• When a body accumulates enough mass, it becomes a star.</p>
                <p>• Change gravity and density in real time.</p>
            </section>
        </div>
        <div class="labels">
            <div class="label">Click and drag to rotate</div>
            <div class="label">Scroll to zoom</div>
            <div class="controls-here" id="controls-here">
                <div class="message"> <div>click</div> <div class="play">play_pause</div> <div>to begin</div> </div>
                <div class="message"> <div>click</div> <div class="play">restart</div> <div>to create a new universe with initial conditions</div> </div>
                <div>Controls here ↓</div>
            </div> 
        </div>
    </div>
    
    <canvas id="canvas"></canvas>

    <!-- entry -->
    <script type="module">
        import { OrbitControls } from "https://threejs.org/examples/jsm/controls/OrbitControls.js";
        class View { 
            constructor({ distance, universeOptions }) {
                this.universeOptions = universeOptions;
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    300000
                );
                this.camera.position.z = distance;
                this.paused = false;

                this.canvas = document.getElementById('canvas');
                let ctx = canvas.getContext('webgl');
                ctx.clearColor(0, 0, 0.1, 0);
                this.canvas.width = canvas.clientWidth;
                this.canvas.height = canvas.clientHeight;

                this.renderer = new THREE.WebGLRenderer({
                    canvas: canvas,
                    canvas: canvas,
                    antialias: true,
                    alpha: true,
                    physicallyCorrectLights: true,
                });
                this.renderer.setViewport(0, 0, canvas.clientWidth, canvas.clientHeight);
                this.renderer.autoClear = false;

                this.composer = new POSTPROCESSING.EffectComposer(this.renderer);
                let renderPass = new POSTPROCESSING.RenderPass(this.scene, this.camera);
                this.composer.addPass(renderPass);

                this.controls = new OrbitControls(this.camera, this.renderer.domElement);

                this.universe = new Universe({
                    ...universeOptions,
                    scene: this.scene,
                    view: this
                });

                this.$real_framerate = $("#real_framerate");

                this.lastRendered = new Date();
                this.countFramesPerSecond = 0;
            }

            onWindowResize() {
                this.canvas.width = canvas.clientWidth;
                this.canvas.height = canvas.clientHeight;
                this.renderer.setViewport(0, 0, canvas.clientWidth, canvas.clientHeight);
                // this.camera.aspect = canvas.clientWidth / canvas.clientHeight;
                this.camera.updateMatrix();
            }

            animate() {
                requestAnimationFrame(this.animate.bind(this));
                window.addEventListener('resize', this.onWindowResize(), false);
                this.renderer.clear();
                this.renderer.clearDepth();
                this.render();
                this.composer.render(0.1);
                this.renderer.render(this.scene, this.camera);
            }

            play_pause() {
                this.paused = this.paused ? false : true ;
            }

            restart() {
                this.scene.children = [];
                this.universe.populate();

                if (this.composer) this.composer.dispose();
                this.composer = new POSTPROCESSING.EffectComposer(this.renderer);
                let renderPass = new POSTPROCESSING.RenderPass(this.scene, this.camera);
                this.composer.addPass(renderPass);

                document.getElementById('canvas').classList.remove('light');
            }

            render() {
                if (!this.prevView) this.prevView = this.view_distance;
                if (this.prevView !== this.view_distance) {
                    this.camera.position.z = this.view_distance;
                }

                if (!this.paused) {

                    let now = new Date();
                    if (this.lastRendered && now.getMilliseconds() < this.lastRendered.getMilliseconds()) {
                        this.$real_framerate.html(this.countFramesPerSecond);
                        this.countFramesPerSecond = 1;
                    } else {
                        this.countFramesPerSecond += 1;
                    }

                    this.universe.scene.children.forEach(child => {
                        child.animate();
                        child.updateMass();
                    })

                    this.lastRendered = new Date();
                }
            }
        }

        class Universe {
            constructor({ n, size, heat, density, spread, gravity, scene, view }) {
                this.initial_number_orbs = n;
                this.initial_orb_radius = size;
                this.initial_speed = heat;
                this.initial_spread = spread;
                this.density = density;
                this.gravity = gravity;
                this.view = view;
                this.scene = scene;

                this.totalMass = 0;
                this.suns = 0;
                this.populate();
            }

            defaults() {
                this.view.camera.position.z = 300
                this.initial_number_orbs = 200
                this.initial_orb_radius = 1
                this.initial_speed = 0.005
                this.initial_spread = 30
                this.density = 5520
                this.gravity = 3000
            }

            populate() {
                for (let i = 0; i < this.initial_number_orbs; i++) {
                    let particle = new Particle({
                        radius: this.initial_orb_radius * (Math.random() + 0.1) ** 10,
                        density: this.density,
                        heat: this.initial_speed,
                        universe: this
                    });
                    particle.position.x = 8 * this.initial_spread * (Math.random() - Math.random())
                    particle.position.y = 3 * this.initial_spread * (Math.random() - Math.random())
                    particle.position.z = 4 * this.initial_spread * (Math.random() - Math.random())
                    
                    this.scene.add(particle);
                }
            }
        }

        class Particle extends THREE.Mesh {
            constructor({ radius, density, heat, universe }) {
                const mass = density * 4 / 3 * Math.PI * radius ** 3;
                const geometry = new THREE.SphereGeometry(radius + 0.1, 30, 30);
                const material = new THREE.MeshPhongMaterial({ color: 0x33F9FF, shininess: 0 })//, emissiveIntensity: 10});
                super(geometry, material);

                this.siblings = universe.scene.children
                this.universe = universe;
                this.universe.totalMass += mass

                this.mass = mass;
                this.radius = radius
                this.density = density;
                this.acceleration = new THREE.Vector3();
                this.velocity = new THREE.Vector3(
                    heat * (Math.random() - Math.random()),
                    heat * (Math.random() - Math.random()),
                    heat * (Math.random() - Math.random()),
                )
            }

            animate() {
                this.siblings.forEach(p2 => {
                    if (this.uuid !== p2.uuid) {
                        this.updateMass()
                        p2.updateMass()
                        let d = this.position.distanceTo(p2.position)
                        if (d <= this.radius + p2.radius) {
                            this.mass > p2.mass ? this.absorb(p2) : p2.absorb(this)
                        } else {
                            this.gravitate(p2)
                        }
                    }
                });
            }

            absorb(p2) {
                if (p2.sun) {
                    p2.godraysEffect.dispose();
                    this.godraysEffect = new POSTPROCESSING.GodRaysEffect(this.universe.view.camera, this, {
                        resolutionScale: 1,
                        density: 1.5,
                        decay: 0.95,
                        weight: 0.1,
                        samples: 100
                    })
                    let effectPass = new POSTPROCESSING.EffectPass(this.universe.view.camera, this.godraysEffect);
                    effectPass.renderToScreen = true

                    effectPass.uniforms = this.universe.suns
                    this.universe.view.composer.addPass(effectPass);
                }
                let newMass = this.mass + p2.mass;

                let newVelocity = new THREE.Vector3(
                    (this.velocity.x * this.mass + p2.velocity.x * p2.mass) / newMass,
                    (this.velocity.y * this.mass + p2.velocity.y * p2.mass) / newMass,
                    (this.velocity.z * this.mass + p2.velocity.z * p2.mass) / newMass
                );

                let newPos = new THREE.Vector3(
                    (this.position.x * this.mass + p2.position.x * p2.mass) / newMass,
                    (this.position.y * this.mass + p2.position.y * p2.mass) / newMass,
                    (this.position.z * this.mass + p2.position.z * p2.mass) / newMass
                );

                this.position.multiplyScalar(0)
                this.position.add(newPos);
                this.velocity = newVelocity

                let newRadius = (3 * newMass / 4 / this.density / Math.PI) ** (1 / 3)
                this.scale.x *= newRadius / this.radius
                this.scale.y *= newRadius / this.radius
                this.scale.z *= newRadius / this.radius

                this.radius = newRadius;
                this.mass = newMass;
                this.universe.scene.remove(p2)
                this.move();

            }

            gravitate(p2) {
                this.updateMass();
                p2.updateMass();
                let force = new THREE.Vector3().subVectors(this.position, p2.position);
                let d = force.length();
                if (d === 0) return;
                let g = this.universe.gravity * -0.0000000000667408
                let dir = force.normalize();
                let strength = - (g * this.mass * p2.mass) / (d * d);

                force = dir.multiplyScalar(strength);
                this.applyForce(force, -1);
                this.accelerate();
                this.move();
            }

            applyForce(force, dir) {
                this.acceleration = (force.multiplyScalar(dir / this.mass))
            }

            accelerate() {
                this.velocity.add(this.acceleration);
                this.acceleration.multiplyScalar(0);
            }

            move() {
                this.position.add(this.velocity);
            }

            updateMass() {
                if (this.sun) {
                    this.density = this.universe.density / 4
                } else {
                    this.density = this.universe.density
                } if (this.mass > 1000000) {//this.universe.totalMass/3){
                    if (!this.sun) {
                        this.density *= 1 / 4;
                        this.material = new THREE.MeshBasicMaterial({ color: 'yellow' })

                        let light = new THREE.PointLight({
                            color: 'yellow',
                            distance: 2,
                            decay: 2
                        });
                        this.add(light);

                        let canvas = document.getElementById('canvas')
                        canvas.classList.add('light')

                        this.godraysEffect = new POSTPROCESSING.GodRaysEffect(this.universe.view.camera, this, {
                            resolutionScale: 1,
                            density: 1.5,
                            decay: 0.95,
                            weight: 0.1,
                            samples: 100
                        })
                        this.godraysEffect.bur = true;
                        let effectPass = new POSTPROCESSING.EffectPass(this.universe.view.camera, this.godraysEffect);
                        effectPass.renderToScreen = true

                        effectPass.uniforms = this.universe.suns
                        this.universe.view.composer.addPass(effectPass);

                        this.sun = true
                        this.universe.suns += 1;
                    }
                    this.children[0].intensity = 0.0000005 * this.mass;
                }
            }
        }

        let options = {
            distance: 500,
            universeOptions: {
                n: 250,
                size: 1,
                heat: 0.005,
                spread: 30,
                density: 5520,
                gravity: 3000,
            }
        }

        const view = new View({
            distance: options.distance,
            universeOptions: options.universeOptions
        });

        const gui = new dat.GUI({ autoplace: false, width: 300 });
        gui.domElement.id = 'gui';

        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('controls-here')
            canvas.appendChild(gui.domElement)
        });

        let f3 = gui.addFolder('Play');
        f3.add(view, 'play_pause');
        f3.add(view, 'restart');
        f3.open();

        // let f1 = gui.addFolder('View (you can also zoom by scrolling)');
        // f1.add(view.camera.position, 'z', 0, 1000);
        // f1.open();

        let f2 = gui.addFolder('Universe');
        f2.add(view.universe, 'initial_number_orbs', 0, 400);
        f2.add(view.universe, 'initial_orb_radius', 1, 2);
        f2.add(view.universe, 'initial_speed', 0, 0.1);
        f2.add(view.universe, 'initial_spread', 1, 1000);
        f2.add(view.universe, 'density', 1, 9000);
        f2.add(view.universe, 'gravity', 0, 10000).step(1);
        f2.open();

        view.animate();
        view.play_pause();
    </script>

</body>
</html>